package shared

import (
	"sync"
	"time"
	"math"
	"continuedb/globalpb"
)

var monoTime struct {
	mu sync.Mutex
	last int64
}

// monotonicUnixNano is used to avoid conflict while
// info generation rate is high.
func monotonicUnixNano() int64 {
	now := time.Now().UnixNano()

	monoTime.mu.Lock()
	defer monoTime.mu.Unlock()
	if now <= monoTime.last {
		monoTime.last++
	} else {
		monoTime.last = now
	}
	return monoTime.last
}

func newInfo(nodeId uint64, val []byte, ttl time.Duration) *Info {
	if nodeId == 0 {
		panic("Can't create info of a uninitialized node.")
	}
	info := &Info{
		NodeId: nodeId,
		Value: globalpb.MakeValueFromBytesAndTimestamp(val, &globalpb.Timestamp{WallTime: time.Now().UnixNano()}),
	}
	info.OrigStamp = monotonicUnixNano()
	info.TtlStamp = info.OrigStamp + int64(ttl)
	if ttl == 0 {
		info.TtlStamp = math.MaxInt64
	}
	return info
}

func (i *Info) isExpired(now int64) bool {
	if now > i.TtlStamp {
		return true
	}
	return false
}

func (i *Info) isFresh(thisNodeId uint64, node *Node) bool {
	// If the info is generated by this node, return false.
	if node != nil && thisNodeId == i.NodeId {
		return false
	}
	if node == nil || i.OrigStamp > node.HighWaterStamp ||
		(i.OrigStamp == node.HighWaterStamp && i.Hops < node.MinHops) {
		return true
	}
	return false
}